<!doctype html><html><head><meta charset="utf=8"><meta content="width=device-width,initial-scale=1" name=viewport><title>Alex's Portfolio</title><link href=favicon.ico rel=icon><link crossorigin href=https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/css/bootstrap.min.css integrity=sha384-SgOJa3DmI69IUzQ2PVdRZhwQ+dy64/BUtbMJw1MZ8t5HZApcHrRKUc4W0kG879m7 rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.4/font/bootstrap-icons.min.css rel=stylesheet><link href=https://brochu.github.io/portfolio/css/main.css rel=stylesheet><body class="index-page bg-light"><main class=main><div class="container mt-4"><a href=javascript:history.back()><i class="bi bi-arrow-left"></i> Back to Portfolio</a></div><div class="container mt-5"><h1 class="title fw-bold">Vulkan Graphics API Tutorial</h1><span class="badge text-bg-dark">C++</span><span class="badge text-bg-dark">Vulkan</span><span class="badge text-bg-dark">CMake</span><div class="container mt-5 p-4 bg-white"><p>I started to develop an interest in graphics programming when I was in university when I took my initial OpenGL course. I really liked having some visual feedback to the code I was writing. I also liked the aspect of real-time programming where you need to keep your logic optimized and short so it can run within 16.67ms for a good refresh rate.<p>After I got into some game programming projects (both at the professional level and hobby level) I wanted to look into how game engines *(Unity3D, Unreal Engine, Godot) handled the rendering systems they needed to send the results of the game logic on screen so the player can see what is happening. At that point, I only knew some OpenGL and the names of some alternatives to OpenGL: Direct X, Vulkan and Metal.<p>Later, I went through some tutorials to learn the basics of DirectX 11 <a href=https://brochu.github.io/portfolio/projects/learningvulkanapi/%7B%7Bsite.baseurl%7D%7D/RayTraceInOneWeekendDx11>(see here)</a> and how it can use the graphics hardware to process algorithms in parallel and get better performance for graphics centric work.<p>After learning a Microsoft specific graphics API, I was interested to move onto learn another one that I could use on a variety of operating systems. I also wanted to test out a new development environment away from Visual Studio. I downloaded Neovim (since I have been using vim mappings in Visual Studio for years now), CMake, Ninja and the Vulkan API to see what I could do with these tools. I was very positively surprised by how easy it was to customize the development experience using Neovim. I also was pretty happy with what I was able to do with CMake and Ninja for building my code. Finally I went to <a href=https://vulkan-tutorial.com/>vulkan-tutorial</a> in order to learn how to use this API.<p>This tutorial helped me a lot to realize just how many steps there are to go from having a 3D scene described in C++ to this scene represented on screen. I found this tutorial also very helpful to show every step in good details to setup Vulkan to go through these steps. After working for some days on this, I learned a lot about:<ul><li>All the different rendering stages: <ul><li>Fixed function stages configuration.<li>Programmable stages, shaders (compute, vertex, fragment).</ul><li>How to compile GLSL shaders to SPV byte code and load them.<li>Just how much needs to be described to create a graphics pipeline.<li>How to setup validation layers to help debugging Vulkan applications.<li>How to work with Vulkan extensions and describe which ones to enable for our project.<li>Interface the output of Vulkan graphics pipeline to a GLFW surface on Windows.<li>How pixel formats work and how they are defined in the Vulkan context.<li>How to visualize the hardware with the different queue families available to us.<li>How color blending happens toward the end of the pipeline<li>How multisampling can happen in Vulkan applications<li>How to use synchronization objects (semaphores, fences) within a graphic pipeline or between GPU and CPU.</ul><p>At first, to make sure everything was in order, I rendered a triangle with some color interpolation as they did in the tutorial I was following. After I was able to get everything working, I changed the triangle to a full screen quad to be able to test some pixel shader implementation (first one being mandelbrot set render)<p>Quick Update: I added some descriptor set that I bound to the fragment shader stage to be able to control the position and the zoom of the rendered mandelbrot set! Some new screenshots added<p>Other Update: I finished the online tutorial that I was following. Went through steps to make sure we are double buffering frames (One frame presenting, one being drawn). Started looking at some other projects to try Vullkan with.<p>Here are some screenshots of the rendered results I was able to get:<div class="carousel slide" id=img-carousel><div class=carousel-indicators><button aria-label="Slide 1" aria-current=true class=active data-bs-slide-to=0 data-bs-target=#img-carousel type=button></button><button aria-label="Slide 2" data-bs-slide-to=1 data-bs-target=#img-carousel type=button></button><button aria-label="Slide 3" data-bs-slide-to=2 data-bs-target=#img-carousel type=button></button><button aria-label="Slide 4" data-bs-slide-to=3 data-bs-target=#img-carousel type=button></button><button aria-label="Slide 5" data-bs-slide-to=4 data-bs-target=#img-carousel type=button></button><button aria-label="Slide 6" data-bs-slide-to=5 data-bs-target=#img-carousel type=button></button><button aria-label="Slide 7" data-bs-slide-to=6 data-bs-target=#img-carousel type=button></button><button aria-label="Slide 8" data-bs-slide-to=7 data-bs-target=#img-carousel type=button></button><button aria-label="Slide 9" data-bs-slide-to=8 data-bs-target=#img-carousel type=button></button><button aria-label="Slide 10" data-bs-slide-to=9 data-bs-target=#img-carousel type=button></button><button aria-label="Slide 11" data-bs-slide-to=10 data-bs-target=#img-carousel type=button></button><button aria-label="Slide 12" data-bs-slide-to=11 data-bs-target=#img-carousel type=button></button></div><div class=carousel-inner><div class="carousel-item active"><img class="d-block w-100" alt=... src=https://brochu.github.io/portfolio/imgs/projs/LearningVulkan_1.png></div><div class=carousel-item><img class="d-block w-100" alt=... src=https://brochu.github.io/portfolio/imgs/projs/LearningVulkan_2.png></div><div class=carousel-item><img class="d-block w-100" alt=... src=https://brochu.github.io/portfolio/imgs/projs/LearningVulkan_3.png></div><div class=carousel-item><img class="d-block w-100" alt=... src=https://brochu.github.io/portfolio/imgs/projs/LearningVulkan_4.png></div><div class=carousel-item><img class="d-block w-100" alt=... src=https://brochu.github.io/portfolio/imgs/projs/LearningVulkan_5.png></div><div class=carousel-item><img class="d-block w-100" alt=... src=https://brochu.github.io/portfolio/imgs/projs/LearningVulkan_6.png></div><div class=carousel-item><img class="d-block w-100" alt=... src=https://brochu.github.io/portfolio/imgs/projs/LearningVulkan_7.png></div><div class=carousel-item><img class="d-block w-100" alt=... src=https://brochu.github.io/portfolio/imgs/projs/LearningVulkan_8.png></div><div class=carousel-item><img class="d-block w-100" alt=... src=https://brochu.github.io/portfolio/imgs/projs/LearningVulkan_9.png></div><div class=carousel-item><img class="d-block w-100" alt=... src=https://brochu.github.io/portfolio/imgs/projs/LearningVulkan_10.png></div><div class=carousel-item><img class="d-block w-100" alt=... src=https://brochu.github.io/portfolio/imgs/projs/LearningVulkan_11.png></div><div class=carousel-item><img class="d-block w-100" alt=... src=https://brochu.github.io/portfolio/imgs/projs/LearningVulkan_12.png></div></div><button class=carousel-control-prev data-bs-slide=prev data-bs-target=#img-carousel type=button><span aria-hidden=true class=carousel-control-prev-icon></span> <span class=visually-hidden>Previous</span></button><button class=carousel-control-next data-bs-slide=next data-bs-target=#img-carousel type=button><span aria-hidden=true class=carousel-control-next-icon></span> <span class=visually-hidden>Next</span></button></div></div></div></main><script crossorigin integrity=sha384-k6d4wzSIapyDyv1kpU366/PK5hCdSbCRGRCMv+eplOQJWyd1fbcAu9OCUj5zNLiq src=https://cdn.jsdelivr.net/npm/bootstrap@5.3.5/dist/js/bootstrap.bundle.min.js></script>